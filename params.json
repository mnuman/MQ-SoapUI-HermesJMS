{
  "name": "MQ, SOAPui & HermesJMS",
  "tagline": "",
  "body": "# Using SoapUI for testing MQ-transport services\r\n\r\n## Introduction\r\nIn environments where IBM has a strong presence (e.g. the financial sector), frequently MQ-based messaging solutions are part of the IT landscape. When building Service Oriented Solutions, unit testing tends to become more difficult, since the usual testing solutions do not offer support for MQ out of the box. In this blog I will describe how I solved the MQ challenges at a customer project, using the Open Source Tools SoapUI and HermesJMS.\r\n\r\n## Setting up ##\r\nFirst things first: setting up the environment. Here, I am assuming you have already setup SoapUI (I used 5.2.0, available from http://www.soapui.org/downloads/soapui/open-source.html) and HermesJMS (I am preferring latest & greatest, version 1.15 is available through http://hermesjms.com/patches/).\r\n\r\n### Setting up HermesJMS ###\r\nNext, you need to startup HermesJMS and create a new session. Switch to the providers tab page to define a new Classpath Group to make the set of WebSphere MQ libraries available to HermesJMS. In this new Classpath Group, you will need to add the location of several JARs from your WebSphere MQ distribution:\r\n* com.ibm.mq.commonservices.jar\r\n* com.ibm.mq.headers.jar\r\n* com.ibm.mq.jar\r\n* com.ibm.mq.jmqi.jar\r\n* com.ibm.mq.pcf.jar\r\n* com.ibm.mq.mqjms.jar\r\n* connector.jar\r\n* dhbcore.jar\r\n[PICTURE HERE-1]\r\nNow, you can start defining your session and connection factory details (channel, hostname, port etc.). This is all you need to define in HermesJMS to get started. You will need to provide some destinations for defining your JMS endpoints.\r\n[PICTURE HERE-2]\r\n\r\n### Setting up SoapUI ###\r\nTo use HermesJMS from SoapUI, the only thing you have to do is to point SoapUI to the installation directory of HermesJMS (Preferences > Tools):\r\n[PICTURE HERE-3]\r\n\r\n## Scenario for test ##\r\nIn this case, we are unit testing a Service Bus 12c component; this Service Bus component is a combination of a pipeline, a proxy exposing this pipeline over local transport a business service. The functionality that is implemented inside the pipeline is not relevant for the current discussion. The business services connect (over MQ transport) to a set of queues, one for the request, another one for the reply, the correlationId relates the messages.\r\n[PICTURE HERE-5]\r\nThe test scenario is the following:\r\n* SoapUI (1) will send a request message to our so-called Gateway Proxy (2), using a custom transport user-header – PUT (Proxy Under Test); this Gateway proxy service (actually a proxy and a pipeline) effectively exposes the Proxy Under Test (3) for testing purposes. It uses the PUT transport user-header to dynamically route the incoming message to the proxy we want to test.\r\n* The proxy forwards the request to the pipeline (4) that implements the logic to be tested.\r\n* At a certain stage, the business service (5) will be invoked by the pipeline (4).\r\n* The business service publishes the request message on the Request Queue (6), using the MQ-transport.\r\n* Now, SoapUI (1) retrieves this request message from the queue.\r\n* An additional script step extracts the relevant information from the metadata and data of the request message that was read from the queue.\r\n* Here, custom logic could be implemented to process/determine the response message.\r\n* SoapUI (1) publishes the response message on the REPLY (7) queue, providing the required metadata\r\n* The business service (5), listening on the REPLY (7) queue picks up the response message through message correlation.\r\n* The response message is processed by the pipeline and travels the reverse path of the response message, eventually ending as the ultimate response to the SoapUI request that was sent in the first step. Here, we usally apply all kinds of checks in the form of “assertions” in our SoapUI test.\r\n\r\nThe interesting steps from a test perspective are mainly steps e through h … this is were the ‘magic’ happens, all other stuff is just basic SoapUI testing.\r\n\r\n### SoapUI Project Setup ###\r\nThe project consists of the WSDL of the service to be called, together with a number of custom project (defined at the project level for reusing in all test suites).\r\n[PICTURE HERE-6]\r\nIn this case, the business service is publishing a specific type of XML message onto the IBM WebSphere MQ, and expect a similar type of XML message in response. This message exchange is not governed by a service contract, however soapUI needs to be tricked in believing that we are exchanging SOAP-messages. So, we reuse the WSDL service contract exposed as the interface of the component we will be testing in this unit test to also expose a JMS endpoint (right-click on the WSDL and “Add JMS endpoint…” to define one):\r\n[PICTURE HERE-7]\r\n\r\n#### Test suite anatomy ####\r\nWhen thinking about the setup, a first challenge is encountered: all interactions with the JMS queues, reading as well as writing is done using a “SOAP Request” test step. However, also the initiating step in soapUI is modelled using a “SOAP Request” test step and these SOAP Requests are blocking in soapUI. Where “SOAP Response” test steps offer the option of specifying the “start step” in order to listen for an incoming request, the “SOAP Request” will block until it receives a response.\r\nAs an alternative in this situation, the test is modelled as a test suite, containing different test cases that are executed in parallel. The first test case (“MQ Request”) contains the soapUI SOAP request to initiate the flow (step a), the second test case (“MQ Response”) contains the soapUI “SOAP Request” test steps to pull the published MQ message from the MQ queue (step e) and publish the response (h) message to the MQ response queue. In between, message metadata is extracted from the message published on the MQ queue using a Groovy script.\r\n[PICTURE HERE-8]\r\nOn the test suite, a Groovy startup script takes care of generating unique values for message identification:\r\n\r\n```Groovy\r\ntestSuite.setPropertyValue(\"MessageId\", 'MSG_' + context.expand( '${=java.util.UUID.randomUUID()}' ))\r\ntestSuite.setPropertyValue(\"RelatesTo\", context.expand( '${=java.util.UUID.randomUUID()}' ))\r\nlog.info \"TestSuite:\" + testSuite.getName() + \", MessageId=\" + testSuite.getPropertyValue(\"MessageId\") + \", RelatesTo=\" + testSuite.getPropertyValue(\"RelatesTo\")\r\n```\r\n\r\n#### The initiating request ####\r\nThe soapUI request message that initiates the interaction is quite straight forward:\r\n[PICTURE HERE-9]\r\n\r\n#### Retrieving the MQ message ####\r\nRetrieving the message from an MQ queue is done easily using a soapUI “SOAP Request” step. In this case, we have specified the URL in such a format that it will only retrieve the published message (and not yet supply the response message):\r\n[PICTURE HERE-10]\r\n\r\nFrom the format of the URL (jms://MQ::-::queue_PREFIX.${GlobalProperty}.${#Project#DSRequestQueue}), you can see the interaction with the messaging system is done as jms; the “MQ” identifier refers to the HermesJMS session. The second argument (“-“) is a placeholder to indicate that a response is not (yet) published, the final argument queue_PREFIX.${GlobalProperty}.${#Project#DSRequestQueue} defines the queue the message is read from; in this case, we have a FIXED part (PREFIX), an environment specific value derived from GlobalProperty and a project specific property value.\r\n\r\n#### Obtaining the correlation value ####\r\nTo assure that the inbound MQ response message can be correlated with the outbound MQ request message, the business service has been setup for correlation on the messageId. This implies that the messageId value from the outbound MQ request message needs to be provided as the JMS correlation Id on the inbound response message.\r\nIn order to retrieve the messageId on the outbound MQ request message, a small snippet of Groovy code is executed to extract this messageId value into a testcase property:\r\n\r\n[PICTURE HERE-11]\r\n\r\n#### Publishing the MQ response ####\r\nThe final step in this scenario consists of publishing the MQ response message to the reply queue (this message is picked up by the business service, based on the correct correlationId), again using a “SOAP Request”:\r\n\r\n[PICTURE HERE-12]\r\n\r\nAs you can see from the URL jms://MQ::queue_PREFIX.${ GlobalProperty}.${#Project#DSReplyQueue}::\r\nthe same MQ session is used for publishing the reply. Also in this case, only one action (writing the message) is involved in the SoapUI request. Again, the queue for publishing this message is composed of several parts, specific to the setup of our environment.\r\n\r\n## Groovy alternative ##\r\nAs an alternative to interacting with MQ over JMS-bindings using HermesJMS, you may also consider interacting with MQ using Groovy Scripts. Roughly, this involves making the JARs mentioned in the setup for HermesJMS available (you can omit the mqjms, pcf and dhbcore JARs), but now soapUI should be aware of them: copy or link the JARs into your `<SOAPUI_HOME>/bin/ext` folder\r\n\r\n### Retrieving an MQ message using Groovy ###\r\n```Groovy\r\n//Connect to the queue manager\r\n//Queue used for putting message\r\ndef propIQueue = testRunner.testCase.getProperty(\"inputqueue\")\r\ndef propHostname = testRunner.testCase.getProperty(\"hostname\") \r\ndef propPort = testRunner.testCase.getProperty(\"port\")\r\ndef propChannel = testRunner.testCase.getProperty(\"channel\")\r\ndef propQM = testRunner.testCase.getProperty(\"queuemanager\")\r\ndef queueManager = new com.ibm.mq.MQQueueManager(propQM.getValue())\r\ncom.ibm.mq.MQEnvironment.@hostname = propHostname.getValue()\r\ncom.ibm.mq.MQEnvironment.@port = Integer.parseInt(propPort.getValue())                       \r\ncom.ibm.mq.MQEnvironment.@channel = propChannel.getValue()        \r\n \r\n//Put message in queue\r\ndef putMsg = new com.ibm.mq.MQMessage();\r\nint putOpenOpts = com.ibm.mq.MQC.MQOO_OUTPUT | com.ibm.mq.MQC.MQOO_FAIL_IF_QUIESCING;\r\ndef putQ = queueManager.accessQueue(propIQueue.getValue(), putOpenOpts);\r\nputMsg.@format = \"MQSTR\";\r\nputMsg.@priority = 2;\r\nm_strCorrelationID = java.util.UUID.randomUUID().toString().replace('-','').substring(0,24);\r\n// push back correlationID string to testcase property\r\ntestRunner.testCase.setPropertyValue(\"strMQCorrelationID\", m_strCorrelationID);\r\nputMsg.@correlationId = m_strCorrelationID.getBytes();\r\nputMsg.@messageId = m_strCorrelationID.getBytes();\r\nputMsg.writeString(\"0101AapNootMies0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\" + m_strCorrelationID);\r\ndef pmo = new com.ibm.mq.MQPutMessageOptions();\r\nputQ.put(putMsg, pmo);\r\nputQ.close()\r\nlog.info \"Publishing MQ correlationId = \"  + putMsg.@correlationId \r\nlog.info \"Publishing MQ messageId = \"  + putMsg.@messageId\r\n```\r\n\r\n### Publishing an MQ message using Groovy ###\r\n\t\r\n```Groovy\r\ndef groovyUtils = new com.eviware.soapui.support.GroovyUtils( context )\r\n//Connect to the queue manager\r\n//Queue used for putting message\r\ndef propIQueue = testRunner.testCase.getProperty(\"inputqueue\")\r\ndef propOQueue = testRunner.testCase.getProperty(\"outputqueue\")\r\ndef propHostname = testRunner.testCase.getProperty(\"hostname\") \r\ndef propPort = testRunner.testCase.getProperty(\"port\")\r\ndef propChannel = testRunner.testCase.getProperty(\"channel\")\r\ncom.ibm.mq.MQEnvironment.@hostname = propHostname.getValue()\r\ncom.ibm.mq.MQEnvironment.@port = Integer.parseInt(propPort.getValue())                       \r\ncom.ibm.mq.MQEnvironment.@channel = propChannel.getValue()        \r\n//setting Queue Manager\r\ndef propQM = testRunner.testCase.getProperty(\"queuemanager\")\r\ndef queueManager = new com.ibm.mq.MQQueueManager(propQM.getValue())\r\ndef getMsg = new com.ibm.mq.MQMessage();\r\nint getOpenOpts =  com.ibm.mq.MQC.MQGMO_WAIT;\r\ncom.ibm.mq.MQGetMessageOptions gmo = new com.ibm.mq.MQGetMessageOptions();\r\ndef getQ = queueManager.accessQueue(propOQueue.getValue(), getOpenOpts);\r\n// retrieve correlationID from testcase property\r\nm_strCorrelationID = testRunner.testCase.getPropertyValue(\"strMQCorrelationID\");\r\n// log.info \"Listening for MQ message with correlationID = \"  + m_strCorrelationID\r\n// listen specifically for the requested correlationID, i.e. the one from the property\r\ngetMsg.@correlationId = m_strCorrelationID.getBytes();\r\ngetMsg.@messageId = com.ibm.mq.MQC.MQMI_NONE;\r\ngmo.@waitInterval = 5000;\r\ngetQ.get(getMsg, gmo);\r\ndef response = getMsg.readString(getMsg.getMessageLength())\r\ngetQ.close()\r\nlog.info \"Received message correlationId: \" + getMsg.@correlationId\r\nlog.info \"Received message messageId: \" + getMsg.@messageId\r\n//log.info \"MQ response received: \"  + response\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}